{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the CloudTalk application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "googleId": {
          "type": "string",
          "description": "The user's Google ID."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "displayName": {
          "type": "string",
          "description": "The user's display name."
        },
        "photoURL": {
          "type": "string",
          "description": "URL of the user's profile photo.",
          "format": "uri"
        },
        "lastLogin": {
          "type": "string",
          "description": "The last login timestamp.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "googleId",
        "email",
        "displayName"
      ]
    },
    "ChatMessage": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChatMessage",
      "type": "object",
      "description": "Represents a chat message.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ChatMessage entity."
        },
        "senderId": {
          "type": "string",
          "description": "Reference to the User who sent the message. (Relationship: User 1:N ChatMessage)"
        },
        "receiverId": {
          "type": "string",
          "description": "Reference to the User who received the message. (Relationship: User 1:N ChatMessage)"
        },
        "content": {
          "type": "string",
          "description": "The content of the message."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp when the message was sent.",
          "format": "date-time"
        },
        "mediaURL": {
          "type": "string",
          "description": "URL of the media file (if any).",
          "format": "uri"
        },
        "messageType": {
          "type": "string",
          "description": "The type of message like text, image, video."
        }
      },
      "required": [
        "id",
        "senderId",
        "receiverId",
        "content",
        "timestamp"
      ]
    },
    "Contact": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Contact",
      "type": "object",
      "description": "Represents a contact in a user's contact list.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Contact entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who owns this contact. (Relationship: User 1:N Contact)"
        },
        "contactUserId": {
          "type": "string",
          "description": "Reference to the User who is the contact. (Relationship: User 1:N Contact)"
        },
        "displayName": {
          "type": "string",
          "description": "The display name of the contact."
        }
      },
      "required": [
        "id",
        "userId",
        "contactUserId",
        "displayName"
      ]
    }
  },
  "auth": {
    "providers": [
      "google.com"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information. Path-based ownership for private user data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/contacts/{contactUserId}",
        "definition": {
          "entityName": "Contact",
          "schema": {
            "$ref": "#/backend/entities/Contact"
          },
          "description": "Stores contact information for a specific user. Path-based ownership for contact data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "contactUserId",
              "description": "The unique identifier for the contact user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/contacts/{contactUserId}/messages/{messageId}",
        "definition": {
          "entityName": "ChatMessage",
          "schema": {
            "$ref": "#/backend/entities/ChatMessage"
          },
          "description": "Stores chat messages between two users.  Path-based ownership for messages.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "contactUserId",
              "description": "The unique identifier for the contact user."
            },
            {
              "name": "messageId",
              "description": "The unique identifier for the chat message."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support a real-time chat application (CloudTalk) with Google authentication. It prioritizes security and scalability, adhering to the principles of Authorization Independence, Structural Segregation, and Access Modeling. User data is stored in `/users/{userId}`. Chat messages between users are stored in `/users/{userId}/contacts/{contactUserId}/messages/{messageId}`. Contact lists are stored in `/users/{userId}/contacts/{contactUserId}`. This structure ensures that each document's security can be validated independently without requiring hierarchical `get()` calls, thus optimizing for atomic operations and simplifying security rules. The design also supports QAPs by segregating data based on ownership and relationship, allowing for efficient listing of messages and contacts within a user's scope."
  }
}
